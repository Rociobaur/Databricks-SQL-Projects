# 游늵 SQL Challenge - An치lisis Completo de Ventas

### **游꿢 Contexto del Proyecto**

<aside>
游늶

El 치rea de Demand Planning requiere informaci칩n con mayor frecuencia de las transacciones de venta y movimientos de mercader칤a realizadas. Para ello genera reportes comerciales a trav칠s del 치rea de Reporting con diversos KPIs e indicadores segmentando por distintas categor칤as.

</aside>

**Programa:** SQL for Data Science in Databricks | Lovelytics LATAM (2025)

**Herramientas:** SQL, Databricks

**Autor:** Roc칤o Baur

---

### **游늵 Modelo de Datos**

El modelo cuenta con las siguientes tablas:

- **Clientes:** Listado de los clientes dados de alta en el sistema de ventas.
- **Empleados:** Maestro de empleados, compuesto por el identificador, nombre, apellido y sucursal en la que trabaja.
- **Locales:** Maestro de sucursales compuesta por el identificador, nombre y tipo de local.
- **Productos:** Maestro de productos con su precio agrupados por familia de producto.
- **Facturas:** Tabla que registra todas las transacciones (ventas). Contiene la fecha de la operaci칩n, el empleado que hizo la venta, el cliente y la cantidad de productos vendidos.

---

### **游눠 An치lisis Realizados**

- **1. Productos Vendidos por A침o**

**Objetivo:** Generar un listado de la cantidad de productos vendidos por a침o de manera descendente.

**C칩digo SQL:**

```sql
SELECT 
  YEAR(fecha_venta) AS `A침o_venta`,
  SUM(cantidad) AS `Total_productos_vendidos`
FROM curso.ventas.facturas
GROUP BY `A침o_venta`
ORDER BY `A침o_venta` DESC;
```

---

- **2. Top-5 Empleados con Menor Rendimiento**

**Objetivo:** Identificar los 5 empleados que menos vendieron seg칰n cantidad vendida, indicando apellido y nombre en un solo campo.

**Resultado:** Los 5 empleados que menos vendieron fueron Jose P칠rez, Maria Gonz치lez, Luis Fern치ndez, Ramon Gonz치lez y Hector.

**C칩digo SQL:**

```sql
SELECT
  CONCAT_WS(' ', e.nombre, 
    CASE WHEN e.apellido = 'null' THEN '' ELSE e.apellido END) AS Nombre_completo_empleado,
  SUM(f.cantidad) AS cantidad_vendida
FROM curso.ventas.facturas AS f
JOIN curso.ventas.empleados AS e
  ON f.vendedor = e.id_vendedor
GROUP BY id_vendedor, 
  CONCAT_WS(' ', e.nombre, 
    CASE WHEN e.apellido = 'null' THEN '' ELSE e.apellido END)
ORDER BY cantidad_vendida ASC
LIMIT 5;
```

---

- **3. Clientes del Mes Anterior**

**Objetivo:** Calcular cu치ntos clientes compraron en el mes anterior.

**Resultado:** En el mes anterior (Agosto 2023) fueron **1,677 clientes** los que compraron.

**Nota metodol칩gica:** Al no haber una fecha de referencia en la consigna, se toma como 'mes actual' el 칰ltimo periodo registrado en la tabla de facturas (2023-09-17), mes de Septiembre. Por lo tanto, el c치lculo se realiza sobre el mes de agosto.

**C칩digo SQL:**

```sql
-- C치lculo fecha de 칰ltimo registro
SELECT * 
FROM curso.ventas.facturas
ORDER BY fecha_venta DESC
LIMIT 1;

-- Consulta principal
SELECT COUNT(DISTINCT cliente) AS `Total_clientes`
FROM curso.ventas.facturas 
WHERE MONTH(fecha_venta) = 08
  AND YEAR(fecha_venta) = 2023;
```

---

- **4. Producto M치s Vendido en 2022**

**Objetivo:** Identificar el producto que se vendi칩 m치s en el a침o 2022 y su familia de producto.

**Resultado:** El producto que se vendi칩 m치s en el a침o 2022 fue el **Tri치ngulo**, de la familia de **Chocolates**, alcanzando un volumen total de **57,911 unidades**.

**C칩digo SQL:**

```sql
SELECT
  nombre,
  familia,
  SUM(f.cantidad) AS Total_ventas
FROM curso.ventas.facturas AS f
JOIN curso.ventas.productos AS p
  ON f.producto = p.id_producto
WHERE YEAR(f.fecha_venta) = 2022
GROUP BY p.nombre, p.familia
ORDER BY total_ventas DESC
LIMIT 1;
```

---

- **5. Producto M치s Rentable en 2022**

**Objetivo:** Identificar el producto m치s rentable del a침o 2022.

**Resultado:** El producto m치s rentable del 2022 fue **H칛agen-Dazs**, con una recaudaci칩n total de **$7,978,518**. Al no contar con informaci칩n sobre los costos unitarios, el c치lculo se basa en el ingreso total generado por las ventas durante dicho periodo.

**C칩digo SQL:**

```sql
SELECT
  p.nombre,
  SUM(cantidad * precio_unitario) AS recaudacion_total
FROM curso.ventas.facturas AS f
JOIN curso.ventas.productos AS p
  ON f.producto = p.id_producto
WHERE YEAR(f.fecha_venta) = 2022
GROUP BY f.producto, p.nombre
ORDER BY recaudacion_total DESC
LIMIT 1;
```

---

- **6. Top-10 Sucursales por Monto Vendido**

**Objetivo:** Obtener las 10 sucursales con mayor facturaci칩n, mostrando tipo de local, nombre y monto vendido.

**Insight clave:** Las sucursales tipo Supermercado lideran la recaudaci칩n, representando la mayor칤a del Top 10. El local **칄xito La 33** es el punto de mayor impacto en las ventas totales.

**C칩digo SQL:**

```sql
SELECT
  tipo AS tipo_local,
  l.nombre,
  SUM(f.cantidad * p.precio_unitario) AS monto_vendido
FROM curso.ventas.productos AS p
JOIN curso.ventas.facturas AS f
  ON p.id_producto = f.producto
JOIN curso.ventas.empleados AS e
  ON f.vendedor = e.id_vendedor
JOIN curso.ventas.locales AS l
  ON e.sucursal = l.id_sucursal
GROUP BY l.nombre, tipo
ORDER BY monto_vendido DESC
LIMIT 10;
```

---

- **7. Detecci칩n de Empleados Inactivos con Ventas Registradas**

**Objetivo:** Identificar ventas realizadas por vendedores que ya no est치n en la compa침칤a.

**Resultado:** Los vendedores identificados con los IDs del 57 al 65 no registran datos de Nombre o Apellido, ya que no se encuentran en la tabla maestra de empleados. Esto confirma que son registros de ventas de personal que ya no pertenece a la compa침칤a. Son un total de **9 empleados**.

**C칩digo SQL:**

```sql
-- Listado de empleados con cantidad de ventas
SELECT
  f.vendedor AS id_venderdor,
  COUNT(*) AS cantidad_ventas
FROM curso.ventas.facturas AS f
LEFT JOIN curso.ventas.empleados AS e
  ON f.vendedor = e.id_vendedor
WHERE e.id_vendedor IS NULL
GROUP BY f.vendedor
ORDER BY cantidad_ventas DESC;

-- Total de ex-empleados
SELECT
  COUNT(DISTINCT f.vendedor) AS total_ex_empleados
FROM curso.ventas.facturas AS f
LEFT JOIN curso.ventas.empleados AS e
  ON f.vendedor = e.id_vendedor
WHERE e.id_vendedor IS NULL;
```

---

- **8. Clasificaci칩n de Vendedores por Rendimiento**

**Objetivo:** Clasificar a los vendedores seg칰n su facturaci칩n del a침o actual en tres categor칤as.

**Criterios:**

- **"Excelente"** si el vendedor ha vendido por m치s de $10 millones.
- **"Bueno"** si el vendedor ha vendido entre $5 y $10 millones.
- **"Regular"** si el vendedor ha vendido menos de $5 millones.

**Insight clave:** Se toma el 2023 como "a침o actual" por ser el 칰ltimo con registros completos. Se observa que **ning칰n vendedor alcanz칩 la categor칤a "Excelente"** (>$10M) en este periodo. Esto sugiere un desplazamiento de la fuerza de ventas hacia los rangos "Bueno" y "Regular", lo que podr칤a deberse a una contracci칩n del mercado o a cambios en el equipo comercial respecto a a침os anteriores.

**C칩digo SQL:**

```sql
SELECT
  e.id_vendedor,
  SUM(p.precio_unitario * f.cantidad) AS total_ventas,
  CASE
    WHEN SUM(p.precio_unitario * f.cantidad) >= 10000000 THEN 'Excelente'
    WHEN SUM(p.precio_unitario * f.cantidad) >= 5000000 THEN 'Bueno'
    ELSE 'Regular'
  END AS rendimiento
FROM curso.ventas.productos AS p
JOIN curso.ventas.facturas AS f
  ON p.id_producto = f.producto
JOIN curso.ventas.empleados AS e
  ON f.vendedor = e.id_vendedor
WHERE YEAR(fecha_venta) = 2023
GROUP BY e.id_vendedor
ORDER BY e.id_vendedor ASC;
```

---

- **9. Vendedores con M치s de 100 Ventas**

**Objetivo:** Mostrar el n칰mero total de facturas para cada vendedor que haya realizado m치s de 100 ventas el a침o anterior, incluyendo nombre del vendedor y cantidad de facturas.

**C칩digo SQL:**

```sql
SELECT
  CONCAT_WS(' ', e.nombre, 
    CASE WHEN e.apellido = 'null' THEN '' ELSE e.apellido END) AS Nombre_empleado,
  COUNT(*) AS cantidad_facturas
FROM curso.ventas.facturas AS f
JOIN curso.ventas.empleados AS e
  ON f.vendedor = e.id_vendedor
WHERE YEAR(f.fecha_venta) = 2022
GROUP BY id_vendedor, e.nombre, e.apellido
HAVING COUNT(*) >= 100
ORDER BY cantidad_facturas DESC;
```

---

- **10. Clientes de Alto Valor por Edad**

**Objetivo:** Generar un listado de los clientes que realizaron m치s de 50 compras y que su edad sea mayor al promedio de edad del total de la base de clientes. Ordenar el listado por edad de manera ascendente.

**Resultado:** La edad promedio de los clientes es de **47 a침os**.

**C칩digo SQL:**

```sql
-- Consulta principal
SELECT
  CONCAT(nombre, ' ', apellido) AS cliente,
  (2023 - YEAR(fecha_nacimiento)) AS edad,
  COUNT(*) AS total_compras
FROM curso.ventas.clientes AS c
JOIN curso.ventas.facturas AS f
  ON c.id_cliente = f.cliente
WHERE (2023 - YEAR(fecha_nacimiento)) >= 
  (SELECT AVG(2023 - YEAR(fecha_nacimiento))
   FROM curso.ventas.clientes)
GROUP BY c.nombre, c.apellido, c.fecha_nacimiento
HAVING COUNT(*) >= 50
ORDER BY edad ASC;

-- C치lculo edad promedio
SELECT
  CAST(AVG(2023 - YEAR(fecha_nacimiento)) AS INT) AS edad_promedio
FROM curso.ventas.clientes;
```

---

### **游꿉 Habilidades Demostradas**

**T칠cnicas SQL**

- Agregaciones (SUM, COUNT, AVG)
- JOINs m칰ltiples
- LEFT JOIN para detecci칩n de datos faltantes
- Subconsultas
- CASE statements
- Funciones de fecha (YEAR, MONTH)
- String manipulation (CONCAT_WS)
- GROUP BY y HAVING
- ORDER BY y LIMIT

**Capacidades Anal칤ticas**

- An치lisis de tendencias temporales
- Identificaci칩n de productos estrella
- An치lisis de rentabilidad
- Segmentaci칩n de clientes
- Evaluaci칩n de desempe침o de empleados
- Detecci칩n de anomal칤as en datos
- KPIs comerciales
- Insights estrat칠gicos

---

### **游늷 Conclusiones Clave**

<aside>
游눠

Este proyecto demuestra capacidad para:

- Trabajar con modelos de datos relacionales complejos
- Resolver problemas de negocio reales mediante SQL
- Generar insights accionables a partir de datos transaccionales
- Identificar oportunidades de mejora operacional
- Documentar an치lisis de manera clara y profesional
</aside>
